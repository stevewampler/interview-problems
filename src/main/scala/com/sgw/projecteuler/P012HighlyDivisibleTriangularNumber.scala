package com.sgw.projecteuler

import com.sgw.problems.PrimeSieve

/**
 * From: https://projecteuler.net/problem=12
 *
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 *
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 *  1: 1
 *  3: 1,3
 *  6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred divisors?
 *
 * Answer: 76,576,500
 */
object P012HighlyDivisibleTriangularNumber extends App {
  val targetFOXSize: Int = 500

  val primes = PrimeSieve.primesList(150000).map(_.toLong).toArray

  println(primes.size)

  def primeFactors(x: Long, primeIndex: Int = 0): List[Long] = try {
    val f1 = primes(primeIndex)

    if (f1 >= x) return List[Long]()

    if (x % f1 == 0) {
      val f2 = x / f1

      f1 :: f2 :: primeFactors(f2, primeIndex)
    } else {
      primeFactors(x, primeIndex + 1)
    }
  } catch {
    case t: Throwable => throw new RuntimeException(s"Field to find the prime factors for $x.", t)
  }

  def factors(x: Long): List[Long] = {
    val pfs = primeFactors(x).sorted

    val pfs2 = pfs.takeWhile(_ <= Math.sqrt(x)) // only need factors <= sqrt(x)

    val ofs = try {
      (2 to pfs2.size).
        map(i => pfs2.combinations(i).map(_.product).filter(_ < x).filter(x % _ == 0).toList).
        takeWhile(_.nonEmpty).
        flatten
    } catch {
      case t: Throwable => throw new RuntimeException(s"Failed to get the factors for $x. pfs=${pfs.mkString(",")}", t)
    }

    //    println(ofs.mkString(","))
    (1L :: x :: pfs ++ ofs).distinct
  }

  def triangles: Iterator[Long] = new Iterator[Long] {
    private var x = 0
    private var sum = 0

    def hasNext: Boolean = true

    def next = {
      x += 1
      sum += x
      sum
    }
  }

  triangles.map(x => (x, factors(x))).map {
    case (x, fox) => (x, fox, fox.size)
  }.filter {
    case (_, _, foxSize) => foxSize > targetFOXSize
  }.map {
    case (x, fox, foxSize) => (x, fox.sorted, foxSize)
  }.take(1).foreach(println)
}
